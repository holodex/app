var Path = require('path');
var Url = require('url');
var traverseAsync = require('traverse-async').traverse;
var traverse = require('traverse');
var Class = require('es-class');
var each = require('async-each');
var extend = require('xtend');
var debug = require('debug')('fs-storage');

var config = require('config');

var stripSlashes = function (name) {
  return name.replace(/^\/|\/$/g, '');
};

var serialize = function serialize (obj) {
  return JSON.stringify(obj, null, 2);
};

var deserialize = function deserialize (str) {
  return JSON.parse(str);
};

module.exports = Class({

  constructor: function (options) {

    this.collection = options.collection || "";

    this.fs = options.fs || require('fs');
    this.fsRoot = options.fsRoot || config.get('data.root');

    this.extname = options.extname || ".json";
    this.serialize = options.serialize || serialize;
    this.deserialize = options.deserialize || deserialize;
  },

  path: function (id) {
    debug("path(", id, ")")

    var path = Path.join(
      this.fsRoot,
      (id[id.length] !== "/") ?
        (id + this.extname) : (id || "")
    );

    debug("path() ->", path);
    return path;
  },

  read: function (path, cb) {
    debug("read(", path, ")");
    this.fs.readFile(path, function (err, buf) {
      if (err) { return cb(err); }

      var str = buf.toString();
      debug("read raw", str);

      var obj = this.deserialize(str);

      debug("read() ->", obj);

      return cb(null, obj);
    }.bind(this));
  },

  write: {
  },

  find: function (params, cb) {
    var path = this.path(this.collection + "/")
    return this.fs.readdir(path, function (err, dirList) {
      var ids = dirList.filter(function (name) {
        return Path.extname(name) === this.extname;
      }, this).map(function (name) {
        return Path.basename(name, this.extname);
      }, this);

      each(ids, function (id, next) {
        return this.get(id, params, next);
      }.bind(this), cb);
    }.bind(this));
  },

  get: function (id, params, cb) {
    debug("get", id, params);

    var seen = {};

    var self = this;

    var init = {
      '@id': this.collection + "/" + id,
    };

    // hack as traverse-async returns initial data object
    var ret;
    debug("traversing object", init);
    var queue = traverseAsync(init, function (node, next) {
      debug("travsersing node", node);

      if (typeof node['@id'] === 'string') {
        var path = self.path(node['@id']);

        if (seen[path]) {
          return next();
        }

        return self.read(path, function (err, obj) {
          if (err) {
            queue.break();
            return cb(err);
          }

          seen[path] = true;

          this.node = extend(obj, {
            '@id': this.node['@id'],
          });
          
          if (!this.parent) {
            ret = this.node;
          } else {
            this.parent[this.key] = this.node;
          }

          queue.push(this);

          return next();
        }.bind(this));
      }
      else {
        return next();
      }
    }, function (newObj) {
      return cb(null, ret)
    });
  },
  create: function () {
  },
  update: function () {
  },
  patch: function () {
  },
  remove: function () {
  },

});
